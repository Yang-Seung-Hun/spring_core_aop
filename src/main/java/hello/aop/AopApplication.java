package hello.aop;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AopApplication {

    public static void main(String[] args) {
        SpringApplication.run(AopApplication.class, args);
    }

}
/**
 * 부가 기능 적용시 문제
 * 1. 부가 기능을 적용할 때 아주 많은 반복이 필요
 * 2. 부가 기능이 여러 곳에 퍼져서 중복 코드를 만들어냄
 * 3. 부가 기능을 변경할 때 중복 때문에 많은 수정이 필요함
 * 4. 부가 기능의 적용 대상을 변경할 때 많은 수정이 필요함
 *
 * => 부가 기능을 핵심 기능에서 분리하고 한 곳에서 관리하도록 하고, 해당 부가 긴능을 어디에 적용할지 선택하는 기능도 만듬
 *    이렇게 부가 기능과 부가 기능을 어디에 적용할지 선택하는 기능을 합쳐 하나의 모듈로 만든 것이 에스펙트임(aspect). (ex) @Aspect
 *    에스펙트를 사용한 프로그래밍 방식을 관점 지향 프로그래밍 AOP(Aspect-Oriented Programming) 이라고 함
 *    (참고) AOP 는 OOP 를 대체하기 위한 것이 아니라 횡단 관심사를 깔끔하게 처리하기 어려운 OOP 의 부족한 부분을 보조하는 목적으로 개발됨
 *
 * AspectJ 플레임워크
 * - AOP 의 대표적인 구현으로 AspectJ 프레임워크 가 있음
 * - 물론 스프링도 AOP 를 지원하지만 대부분 AspectJ 의 문법을 차용하고, AspectJ 가 제공하는 기능의 일부만 제공함
 *
 * AOP 적용 방식
 * AOP 를 사용하면 핵심 기능과 부가 기능이 코드상 안전히 분리되어 관리되는데, 그렇다면 AOP 를 사용할 때 부가 기능 로직은 어떤 방식으로 실제 로직에 추가 될까?
 * => 크게 3가지 방식이 있음
 *    1. 컴파일 시점
 *       - .java 소스 코드를 컴파일러를 사용해서 .class 를 만드는 시점에 부가 기능 로직을 추가함. 이때 AspectJ 가 제공하는 특별한 컴파일러를 사용해야 함
 *         컴파일 된 .class 를 디컴파일 해보면 애스펙트 관련 호출 코드가 들어간 것을 확인할 수 있음. 쉽게 말해 부가 기능 코드가 핵심 기능이 있는 컴파일된 코드 주변에 실제로 붙어 버린다고 생각하면 됨
 *         AspectJ 컴파일러는 Aspect 를 확인해서 해당 클래스가 적용 대상인지 먼저 확인하고, 적용 대상인 경우에 부가 기능을 적용함
 *         참고로 이렇게 원본 로직에 부가 기능이 추가되는 것을 위빙(Weaving)이라 함
 *         (-)컴파일 시점에 부가 기능을 적용하려면 특별한 컴파일러도 필요하고 복작함
 *    2. 클래스 로딩 시점
 *       - 자바를 실행하면 자바 언어는 .class 파일을 JVM 내부의 클래스 로더에 보관함. 이때 중간에서 .class 파일을 조작한 다음 JVM 에 올릴 수 있음
 *         많은 모니터링 툴들이 이 방식을 많이 사용함
 *         이런 방식을 로드 타임 위빙이라고 함
 *         (-)자바를 실행할 때 특별한 옵션(java -javaagent)을 통해 클래스 로더 조작기를 지정해야하는데, 이 부분이 번거롭고 운영하기 어려움
 *    3. 런타임 시점(프록시)
 *       - 런타임 시점은 컴파일도 다 끝나고, 클래스 로더에 클래스도 다 올라가서 이미 자바가 실행되고 난 다음을 의미함(자바의 main 메서드가 이미 실행된 다음)
 *         따라서 자바 언어가 제공하는 범위 안에서 부가 기능을 적용해야함
 *         스프링과 같은 컨테이너의 도움을 받고 프록시와 DI, 빈 포스트 프로세서 같은 개념들을 총 동원해야 함
 *         지금까지 학습한 것이 프록시 방식의 AOP 임
 *
 * AOP 적용 위치
 * AOP 는 지금까지 학습한 메서드 실행 위치 뿐만 아니라 다음과 같은 다양한 위치에 적용할 수 있음
 * - 적용 가능 지점(조인 포인트) : 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행
 * - AspectJ 를 사용해서 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP 는 바이트코드를 실제 조작하기 때문에 해당 기능을 모든 지점에 다 적용 할 수 있음
 * - 프록시 방식을 사용하는 스프링 AOP 는 메서드 실행 지점에만 AOP 를 적용할 수 있음
 *      - 프록시는 메서드 오바라이딩 개념으로 적용함. 따라서 생성자나 static 메서드, 필드 값 접근에는 프록시 개념이 적용 될 수 없음
 *      - 프록시를 사용하는 스프링 AOP 의 조인 포인트는 메서드 실행으로 제한됨
 * - 프록시 방식을 사용하는 스프링 AOP 는 스프링 컨테이너가 관리할 수 있는 스프링 빈에만 AOP 를 적용할 수 있음
 *
 * 더 복잡하고 다양한 기능을 제공하는 AspectJ 를 직접 사용해 AOP 를 적용하는 방식보다 스프링 AOP 를 사용하는 이유
 * => AspectJ 를 사용하려면 공부할 내용도 많고, 자바 관련 설정(특별한 컴파일러, AspectJ 전용 문법, 자바 실행 옵션)도 복잡한 반면
 *    스프링 AOP 는 별도의 추가 자바 설정 없이 스프링만 있으면 편리하게 AOP 를 사용할 수 있음
 *    실무에서는 스프링이 제공하는 AOP 기능만 사용해도 대부분의 문제를 해결 할 수 있음
 *
 * AOP 용어 정리
 * - 조인 포인트(Join Point)
 *    - 어드바이스가 적용될 수 있는 위치, 메소드 실행, 생성자 호출, 필드 값 접근, static 메서드 접근 같은 프로그램 실행 중 지점
 *    - 조인 포인트는 추상적인 개념임. AOP 를 적용할 수 있는 모든 지점이라고 생각하면 됨
 *    - 스프링 AOP 는 프록시 방식을 사용하므로 조인 포인트는 항상 메소드 실행 지점으로 제한됨
 * - 포인트컷(Pointcut)
 *    - 조인 포인트 중에서 어드바이스가 작용될 위치를 선별하는 기능
 *    - 주로 AspectJ 표현식을 사용해서 지점
 *    - 프록시를 사용하는 스프링 AOP 는 메서드 실행 지점만 포인트컷으로 선별함
 * - 타겟(Target)
 *    - 어드바이스를 받는 객체, 포인트컷으로 결정
 * - 어드바이스(Advice)
 *    - 부가 기능
 *    - 특정 조인 포인트에서 Aspect 에 의해 취해지는 조치
 *    - Around, Before, After 와 같은 다양한 종류의 어드바이스가 있음
 * - 에스펙트(Aspect)
 *    - 어드바이스 + 포인트컷을 모듈화 한 것
 *    - @Aspect 를 생각하면 됨
 *    - 여러 어드바이스와 포인트 컷이 함께 존재
 * - 어드바이저(Advisor)
 *    - 하나의 어드바이스와 하나의 포인트 컷으로 구성
 *    - 스프링 AOP 에서만 사용되는 특별한 용어
 * - 위빙(Weaving)
 *    - 포인트컷으로 결정한 타켓의 조인 포인트에 어드바이스를 적용하는 것
 *    - 위빙을 통해 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가 할 수 있음
 *    - AOP 적용을 위해 애스펙트를 객체에 연결한 상태 (컴파일 타임, 로드 타임, 런타임)
 * - AOP 프록시
 *    - AOP 기능을 구현하기 위해 만드 프록시 객체, 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시임
 */